---
marp: true
# theme: github
class: invert
# paginate: true
---

<style>
  .container {
    display: flex;
    justify-content: space-around;
    align-items: center;
  }
  .container.col {
    margin: 1rem;
    width: 100%;
    height: 100%;
  }
  h1 {
    font-size: 2rem;
    text-align: center;
  }
  h1,h2,h3,h4,h5,h6 {
    margin: 0;
  }
</style>

<div class="container">
  <div classs="col">
    <img src="https://upload.wikimedia.org/wikipedia/commons/4/4c/Typescript_logo_2020.svg" />
  </div>

  <div classs="col">
    <img src="https://upload.wikimedia.org/wikipedia/commons/3/3b/Javascript_Logo.png" />
  </div>
</div>

---

<!--color: white-->
<!--backgroundColor: #3178c6-->

# <!--fit-->TypeScript

---

# Static typechecker for JavaScript programs

<!-- A tool that runs _before_ your code runs (static) -->
<!-- Ensures that the types of the program are correct (typechecked) -->

---

<!-- Suppose -->

##### staticTypechecker/greet.ts

```ts
const greet = (person: string, date: Date) => {
  console.log(`Hello ${person}, today is ${date}!`);
};
 
greet('Luke'); // ❌
```

---

<!-- Install TypeScript and run our file -->

```sh
$ npm i -g typescript
```

```sh
$ tsc --noEmitOnError staticTypechecker/greet.ts
greet.ts:9:1 - error TS2554: Expected 2 arguments, but got 1.

9 greet("Luke");
  ~~~~~~~~~~~~~~~~

  greet.ts:3:31
    3 type Greet = (person: Person, date: Date) => void;
                                    ~~~~~~~~~~
    An argument for 'date' was not provided.


Found 1 error in greet.ts:9
```

<!-- This is more or less what you'll see in intellisense if applicable -->

---

##### staticTypechecker/greetToo.ts

```ts
const greetToo = (person: string, date: Date) => {
  console.log(`Hello ${person}, today is ${date}!`);
};
 
greetToo('Luke', new Date()); // ✅
```

```sh
$ tsc --noEmitOnError staticTypechecker/greetToo.ts
```

##### staticTypechecker/greetToo.js

```js
var greetToo = function (person, date) {
    console.log("Hello ".concat(person, ", today is ").concat(date, "!"));
};
greetToo('Luke', new Date()); // ✅
```

<!-- Type annotations are gone -->
<!-- Browsers don't recognize TypeScript, needs compiled to Javascript -->

<!-- Template string syntax converted to string concatenation -->
<!-- Able to write in latest ECMAScript and compiler "downlevels" to ECMAScript 3 ubiquitous to browsers -->

<!-- Type annotations never change the runtime behavior of your program. -->

---

# Types

---

# Primitive Types

##### types/primitiveTypes.ts

```ts
// let name: string
let name = 'Luke';

// const age: number
const age: number = 25; // at heart

// const isAwesome: boolean
const isAwesome: boolean = true;

// const secondsUntilDeceased: bigint
const secondsUntilDeceased = BigInt(10e307);

// let access: symbol
let access: symbol;

// const myNull: null
const myNull = null;

// const yomi: undefined
const yomi = undefined;
```

---

# Union Types

##### types/unionTypes.ts

```ts
type Flag = 'auto' | 'all' | 'rec'; // union of string literals
type Options = { width: number; height: number };

const configure = (x: Options | Flag) => {};

configure({ width: 100, height: 100 }); // ✅
configure('auto'); // ✅
configure('automatic'); // ❌
// Argument of type '"automatic"' is not
//   assignable to parameter of type 'Options | Flag'
```

---

# Function Types

---

# Function Type Expressions

##### types/functionTypes/functionTypeExpressions.ts

```ts
type GreeterFn = (a: string) => void;
const greeter = (fn: GreeterFn) => fn('Hello, World'); // ✅

greeter(console.log);

// Parameter name is required:
type HiFn = (string) => void; // ✅ (but also ❌)
// Parameter has a name but no type.
//   Did you mean 'arg0: string'?
// (parameter) string: any
```

---

# Generic Functions

##### types/functionTypes/genericFunctions.ts

```ts
// const firstElement: (arr: any[]) => any
const firstElement = (arr: any[]) => arr[0]; // ❌

// const firstElementToo: <Type>(arr: Type[]) => Type | undefined
const firstElementToo = <Type>(arr: Type[]): Type | undefined => arr[0]; // ✅

// const s: string | undefined
const s = firstElementToo(['a', 'b', 'c']);
// const u: undefined
const u = firstElementToo([]);

// Inference

const myMap = <In, Out>(arr: In[], func: (arg: In) => Out): Out[] => arr.map(func);

// (parameter) n: string
// const parsed: number[]
const parsed = myMap(['1', '2', '3'], (n) => parseInt(n));
```

<!-- Note that in this example (parsed), TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression (number). -->

---

# Constraints

##### types/functionTypes/constraints.ts

```ts
const longest = <T extends { length: number }>(a: T, b: T) =>
  (a.length >= b.length) ? a : b;
 
// const longerArray: number[]
const longerArray = longest([1, 2], [1, 2, 3]);
// const longerString: "alice" | "bob"
const longerString = longest('alice', 'bob');

const notOK = longest(10, 100); // ❌
// Argument of type 'number' is not assignable
//   to parameter of type '{ length: number; }'
```

---

# Constraints (cont'd)

<!-- Common problem! -->

##### types/functionTypes/constraintsContd.ts

```ts
type MinLength = <T extends { length: number }>(obj: T, min: number) => T;

const minLength: MinLength = (obj, min) => {
  if (obj.length >= min) {
    return obj;
  } else {
    return { length: min };
// T '{ length: number; }' is not assignable to type 'T'.
//   '{ length: number; }' is assignable to the constraint of type 'T',
//     but 'T' could be instantiated with a different
//     subtype of constraint '{ length: number; }'.
  }
};

// 'arr' gets value { length: 6 }
const arr = minLength([1, 2, 3], 6);
// and crashes here because the returned object doesn't have a 'slice' method!
console.log(arr.slice(0)); // ❌
```

<!-- It might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work: -->

---

# Specifying Type Arguments

##### types/functionTypes/specifyingTypeArguments.ts

```ts
const combine = <T>(a1: T[], a2: T[]): T[] => a1.concat(a2);

const arr = combine([1, 2, 3], ['hello']); // ❌
// Type 'string' is not assignable to type 'number'.

// const shhIsOk: (string | number)[]
const shhIsOk = combine<string | number>([1, 2, 3], ['hello']); // ✅
```

---

# Best Practices

##### types/functionTypes/bestPractices.ts

```ts
// Push type parameters down
const firstElement = <T extends any[]>(a: T)  => a[0]; // ❌
const b = firstElement([1, 2, 3]); // ❌ const b: any
const firstElementToo = <T>(a: T[])  => a[0]; // ✅
const a = firstElementToo([1, 2, 3]); // ✅ const a: number

// Use fewer type Parameters
const filter = <T, F extends (arg: T) => boolean>(a: T[], f: F): T[] => a.filter(f); // ❌
const filterToo = <T>(a: T[], f: (arg: T) => boolean): T[] => a.filter(f); // ✅
```

---

# Optional Parameters

##### types/functionTypes/optionalParameters.ts

```ts
// (parameter) x: number | undefined
const f = (x?: number) => x;
f(); // ✅ -> undefined
f(10); // ✅ -> 10
f(undefined); // ✅ -> undefined
f(null); // ✅ -> null

// (parameter) x: number
const g = (x: number = 5) => x;
g(); // ✅ -> 5
g(20); // ✅ -> 20
g(undefined); // ✅ -> 5
g(null); // ✅ -> null
```

---

# void

<!-- void represents the return value of functions which don’t return a value -->
<!-- It’s the inferred type any time a function doesn’t have any return statements -->
<!-- In JavaScript, a function that doesn’t return any value will implicitly return the value undefined -->
<!-- However, void and undefined are not the same thing in TypeScript -->

##### types/functionTypes/void.ts

```ts
// const noop: () => void
const noop = () => {};
noop(); // -> undefined

// const noopExplicit: () => void
const noopExplicit = () => { return; };
noopExplicit() // -> undefined

type VoidFunc = () => void;
const f: VoidFunc = () => 'hi'; // ✅ ... wait, what?
const result = f().length; // ❌ -> 2
// Property 'length' does not exist on type 'void'

// Array<T>.forEach(cb: (v: T, i: T, a: T[]) => void, thisArg?: any ): void
// Array<number>.push(...items: number[]): number
const a = [0];
[1, 2, 3].forEach((el) => a.push(el)); // ✅
```

<!-- Array#push returns a number (the new length of the array), but it's a safe substitute to use for a void-returning function. -->

<!-- Another way to think of this is that a void-returning callback type says "I'm not going to look at your return value, even if one exists". -->
<!-- In other words, it doesn't matter what the return value is, it could be anything but it's inconsequential -->

---

# object

<!-- The special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined) -->

##### types/functionTypes/object.ts

```ts
type MyObject = object; // `any` adjacent

let myObject: MyObject;

myObject = {}; // ✅
myObject = { hi: 'hey' }; // ✅

// Because functions;
//  - have Object.prototype in their prototype chain
//  - are instanceof Object
//  - you can call Object.keys on them
//  - etc.
myObject = () => {}; // ✅

myObject = 42; // ❌
// Type 'number' is not assignable to type 'object'
```

---

# unknown

<!-- The unknown type represents any value -->
<!-- Similar to the any type, but safer because it’s not legal to do anything with an unknown value -->

##### types/functionTypes/unknown.ts

```ts
const f = (a: any) => a.b(); // ✅ (but also ❌)

const g = (a: unknown) => a.b(); // ❌
// 'a' is of type 'unknown'

const h = (a: unknown) => a; // ✅
```

 <!-- Allows you to describe functions that accept any value without having any values in your function body. -->

---

# never

<!-- Means that the function throws an exception or terminates execution of the program. -->
<!-- Has other confusing meanings -->

##### types/functionTypes/never.ts

```ts
const fail = (msg: string): never => {
  throw new Error(msg);
};
```

---

# Function

<!-- Has the special property that values of type Function can always be called but these calls return any -->

##### types/functionTypes/function.ts

```ts
// const doSomething: (f: Function) => any
const doSomething = (f: Function) => f(); // ❌ Unsafe

// const doSomethingToo: (f: () => void) => void
const doSomethingToo = (f: () => void) => f(); // ✅ Safer
```

---

# Rest Parameters And Arguments

<!-- implicitly any[] instead of any -->
<!-- type annotations must be given in the form Array<T> or T[], or a tuple type (later) -->
<!-- Arrays are mutable so it's best to freeze them -->

<!-- TODO explain why the failure -->

##### types/functionTypes/restParametersAndArguments.ts

```ts
// const myMax: (...nums: number[]) => number
const myMax = (...nums: number[]) => Math.max(...nums);

const theseNumbers = [1, 2];
const thisMax = myMax(...theseNumbers); // ✅
const thatMax = myMax(...[3, 4, 5]); // ✅
const theOtherMax = myMax(6, 7, 8, 9); // ✅

// const fullName: (fname: string, lname: string) => string
const fullName = (fname: string, lname: string) => `${fname} ${lname}`;

const myNames = ['Luke', 'Winningham'];
const myFullName = fullName(...myNames); // ❌
// A spread argument must either have a tuple type or be passed to a rest parameter.

const myNamesToo = ['Luke', 'Winningham'] as const; // `as const`
const myFullNameToo = fullName(...myNamesToo); // ✅

const myNamesAgain = ['Luke', 'Winningham'] as [string, string];
const myFullNameAgain = fullName(...myNamesAgain); // ✅
```

<!-- The failure is because TypeScript doesn't know that the array length matches the call signature requirements because the array could mutate at runtime. We can 'freeze' it with `as const` or we can type the array as Tuple type with `as [string, string]`, more on Tuple type later -->

---

# Parameter Destructuring

##### types/functionTypes/parameterDestructuring.ts

```ts
type User = { id: string, name: string; age: number; iq: number };

// Require `id`, all other properties optional
type GetUserParams = Partial<User> & Pick<User, 'id'>;

const getUser = ({ id, name = '', age, iq: userIQ }: GetUserParams): User => {
  const userAge = age === undefined ? 39 : age; // ❌ boo hiss

  const averageIQ = getAverageIQ();
  const iq = userIQ ?? averageIQ; // ✅

  return { id, name, age: userAge, iq };
};

const user = getUser({ id: 'a1b2c3d4' }); // ✅
```

---

# Objects

---

# Optional

##### types/objects/optional.ts

```ts
type User = { name?: string };
const user1: User = {}; // ✅
const user2: User = { name: 'Luke' }; // ✅
// const username1: string | undefined
const { name: username1 } = user1;
// const username2: string | undefined
const { name: username2 } = user2;

type Concrete<Type> = { [Property in keyof Type]-?: Type[Property] };

type ConfidentUser = Concrete<User>;

const confidentUser1: ConfidentUser = {}; // ❌
// Property 'name' is missing in type '{}' but required in type 'Concrete<User>'

const confidentUser2: ConfidentUser = { name: 'Luke' }; // ✅
// const confidentUserName2: string
const { name: confidentUserName2 } = confidentUser2;
```

---

# Readonly

##### types/objects/readonly.ts

```ts
type User = { name: string };
const user: User = { name: 'Luke' };
user.name = '!Luke'; // ✅

type ImmutableUser = { readonly name: string };
const immutableUser: ImmutableUser = { name: 'Luke' };
immutableUser.name = '!Luke'; // ❌
// Cannot assign to 'name' because it is a read-only property.

type Immutable<Type> = Readonly<Type>;
type Mutable<Type> = { -readonly [Property in keyof Type]: Type[Property] };

type MutableUser = Mutable<ImmutableUser>;
const mutableUser: MutableUser = { name: 'Luke' };
mutableUser.name = '!Luke'; // ✅
```

---

# Index Signatures

<!-- Useful for implementing the "dictionary" pattern -->

##### types/objects/indexSignatures.ts

```ts
type NumberDictionary = {
  [index: string]: number;
  length: number; // ✅
  name: string; // ❌
  // Property 'name' of type 'string' is not assignable to 'string' index type 'number'
};

type NumStrDict = {
  readonly [index: string]: number | string;
  length: number; // ✅
  readonly name: string; // ✅
};

const dictionary: NumStrDict = { length: 4, name: 'dict', hi: 'hey', why: 42 };

dictionary.length = 5; // ✅
dictionary.name = 'hwoops'; // ❌
// Cannot assign to 'name' because it is a read-only property.
dictionary.hi = 'oh no'; // ❌
// Index signature in type 'NumStrDict' only permits reading.
```

---

# Arrays

##### types/objects/arrays.ts

```ts
type MyArray<Type> = Array<Type>;
// same as
type MyArrayToo<Type> = Type[];

type MyImmutableArray<Type> = ReadonlyArray<Type>;
// same as
type MyImmutableArrayToo<Type> = readonly Type[];

const myArray: string[] = [];
myArray.push('hello'); // ✅

const myImmutableArray: readonly string[] = ['hi', 'hey', 'yo'];
myImmutableArray.push('sup'); // ❌
// Property 'push' does not exist on type 'readonly string[]'
```

---

# Tuples

<!-- A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. -->

##### types/objects/tuples.ts

```ts
type Name = [string, string];
const name: Name = ['Luke', 'Winningham']; // ✅
const badName: Name = ['Lucas', 'James', 'Winningham']; // ❌
// Type '[string, string, string]' is not assignable to type 'Name'.
//   Source has 3 element(s) but target allows only 2.

type State<T> = [T, (newState: T) => T];

type Coordinates = [number, number, number?]; // 2D or 3D
const d2: Coordinates = [1, 2]; // ✅
const d3: Coordinates = [3, 4, 5]; // ✅

type Pair = [string, number];
// (parameter) one: string
// (parameter) two: number
const getPair = ([one, two, three]: Pair) => {}; // ❌
// Tuple type 'Pair' of length '2' has no element at index '2'.

type ReadonlyArbitraryTuple = readonly [string, number, ...boolean[]];
const readonlyArbitraryTuple: ReadonlyArbitraryTuple = ['world', 3, true, false];
readonlyArbitraryTuple[0] = 'hello'; // ❌
// Cannot assign to '0' because it is a read-only property.
```

---

# Generics

<!-- We've already seen examples of generics -->

---

# keyof

##### generics/keyof.ts

```ts
const getProperty = <Type, Key extends keyof Type>(obj: Type, key: Key) => obj[key];
const x = { a: 1, b: 2, c: 3 };
getProperty(x, 'a'); // ✅
getProperty(x, 'd'); // ❌
// Argument of type '"d"' is not assignable to parameter of type '"a" | "b" | "c"

type Point = { x: number; y: number };
// type P = "x" | "y"
type P = keyof Point;

type Arrayish = { [n: number]: unknown };
// type A = number
type A = keyof Arrayish;

type Mapish = { [k: string]: boolean };
// type M = string | number
type M = keyof Mapish;

// JavaScript object keys are always coerced to a string,
// so obj[0] is always the same as obj["0"]
```

---

# typeof

<!-- exists in JavaScript already -->

##### generics/typeof.ts

```ts
console.log(typeof "Hello world"); // -> "string"

const f = () => ({ x: 10, y: 3 });

type Return = ReturnType<f>; // ❌
// 'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?

// type FReturn = { x: number; y: number }
type FReturn = ReturnType<typeof f>; // ✅
```

---

# Indexed Access Types

##### generics/indexedAccessTypes.ts

```ts
type Person = { age: number; name: string; alive: boolean };
type People = Person[];
const people: People = [{ name: 'Eve', age: 38, alive: false }];

// type Age = number
type Age = Person['age'];
// type AgeOrName = string | number
type AgeOrName = Person['age' | 'name'];
// type KeyOfPerson = string | number | boolean
type KeyOfPerson = Person[keyof Person];

const aliveKey = 'alive';
type Alive = Person[aliveKey]; // ❌
// 'aliveKey' refers to a value, but is being used as a type here. Did you mean 'typeof aliveKey'?
type AliveToo = Person['alve']; // ❌
// Property 'alve' does not exist on type 'Person'

type AliveKeyOrNameKey = 'alive' | 'name';
// type AliveOrName = string | boolean
type AliveOrName = Person[AliveKeyOrNameKey];

// type PeoplePerson = { name: string; age: number; alive: boolean }
type PeoplePerson = typeof people[number];
// type AgeToo = number
type AgeToo = typeof people[number]['age'];
```

---

# Conditional Types

##### generics/conditionalTypes.ts

```ts
type Flatten<T> = T extends any[] ? T[number] : T;

// type Str = string
type Str = Flatten<string[]>;

// type Num = number
type Num = Flatten<number>;

// Using `infer`
type FlattenToo<Type> = Type extends Array<infer Item> ? Item : Type;
type ReturnTypeToo<T> = T extends (...a: never[]) => infer Return ? Return : never;

// Distribution

type ToArray<Type> = Type extends any ? Type[] : never;
// type StrArrOrNumArr = string[] | number[]
type StrArrOrNumArr = ToArray<string | number>;

type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;
// type StrOrNumArr = (string | number)[]
type StrOrNumArr = ToArrayNonDist<string | number>;
```

---

# Mapped Types

##### generics/mappedTypes.ts

```ts
// generate types from other types
type OptionsFlags<Type> = { [Property in keyof Type]: boolean };
type TSCompile = { pretty: () => void; strict: () => void; noEmit: () => void };
// type TSCompileOptions = { pretty: boolean; strict: boolean; noEmit: boolean }
type TSCompileOptions = OptionsFlags<TSCompile>;

type WithGetters<Type> = {
  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
};

type User = { name: string; age: number; location: string };

// type GettableUser = { getName: () => string; getAge: () => number; getLocation: () => string }
type GettableUser = WithGetters<User>;

// Iterate over union
type Callable<UnionTypes extends { kind: string }> = {
  [Type in UnionTypes as Type['kind']]: (event: Type) => void;
}

type Square = { kind: 'square', l: number };
type Circle = { kind: 'circle', r: number };

// type ShapesCallable = { square: (event: Square) => void; circle: (event: Circle) => void }
type ShapesCallable = Callable<Square | Circle>;
```

---

# Template Literal Types

##### generics/templateLiteralTypes.ts

```ts
// type Interjection = "HEY" | "HI"
type Interjection = Uppercase<'hey' | 'hi'>;
// type FormalGreeting = "Greetings" | "Hello"
type FormalGreeting = Capitalize<'greetings' | 'hello'>;
// type Target = "world" | "munda"
type Target = Lowercase<'World' | 'Munda'>;
 
// type Greetings =
//   "HEY, world!" |
//   "HEY, munda!" |
//   "HI, world!" |
//   "HI, munda!" |
//   "Greetings, world!" |
//   "Greetings, munda!" |
//   "Hello, world!" |
//   "Hello, munda!"
type Greetings = `${Interjection | FormalGreeting}, ${Target}!`;
// Honorable mention: Uncapitalize
```

---

# Utility Types: setup

##### generics/utilityTypes/shapes.ts

```ts
type Circle = { kind: 'circle'; r: number };
type Square = { kind: 'square'; l?: number };
type Triangle = { kind: 'triangle'; b: number; h: number };
type Shape = Circle | Square | Triangle;
```

---

# Utility Types: Partial / Required / Readonly

##### generics/utilityTypes/partialRequiredAndReadonly.ts

```ts
import { Circle, Square, Triangle } from './shapes';

const partialCircle: Partial<Circle> = {}; // ✅

const requiredSquare: Required<Square> = { kind: 'square' }; // ❌
// Property 'l' is missing in type '{ kind: "square"; }' but
// required in type 'Required<Square>'

const readonlyTriangle: Readonly<Triangle> = { kind: 'triangle', b: 3, h: 12 };
readonlyTriangle.b = 4; // ❌
// Cannot assign to 'b' because it is a read-only property
```

---

# Utility Types: Record

<!-- TODO: type this as corresponding shapes to their strings? -->

##### generics/utilityTypes/record.ts

```ts
import { Circle, Shape, Square, Triangle } from './shapes';

const shapes: Record<string, Shape> = {
  myCircle: {} as Circle,
  mySquare: {} as Square,
  myTriangle: {} as Triangle,
};
```

---

# Utility Types: Omit / Pick

##### generics/utilityTypes/omitAndPick.ts

```ts
import { Triangle } from './shapes';

// type TriangleKind = { kind: 'triangle' }
type TriangleKind = Omit<Triangle, 'b' | 'h'>;

// type TriangleProperties = { b: number; h: number }
type TriangleProperties = Pick<Triangle, 'b' | 'h'>;
```

---

# Utility Types: Exclude / Extract

##### generics/utilityTypes/excludeAndExtract.ts

```ts
import { Shape } from './shapes';

// type NotCircle = Square | Triangle
type NotCircle = Exclude<Shape, { kind: 'circle' }>;

// type ExtractedCircle = Circle
type ExtractedCircle = Extract<Shape, { kind: 'circle' }>;
```

---

# Utility Types: Parameters / ReturnType

##### generics/utilityTypes/parametersAndReturnType.ts

```ts
import { Shape } from './shapes';

const makeShape = <T extends Shape>(params: Shape): Shape => params as T;

// type MakeShapeParams = [params: Shape]
type MakeShapeParams = Parameters<typeof makeShape>;

// type MakeShapeReturn = Circle | Square | Triangle
type MakeShapeReturn = ReturnType<typeof makeShape>;
```

---

# Utility Types: Awaited

##### generics/utilityTypes/awaited.ts

```ts
import { Circle, Shape } from './shapes';

// type AwaitedCircle = Circle
type AwaitedCircle = Awaited<Promise<Circle>>;

// type AwaitedShape = Circle | Square | Triangle
type AwaitedShape = Awaited<Promise<Promise<Promise<Shape>>>>;
```

---

# Quiz

---

##### generics/quiz.ts

```ts
type WhatIsThis<T> = T extends object ? { [P in keyof T]+?: WhatIsThis<T[P]>; } : T;
```

---

##### generics/deepPartial.ts

```ts
type DeepPartial<T> = T extends object ? { [P in keyof T]+?: DeepPartial<T[P]>; } : T;

type User = { profile: { address: { street: string; city: string; state: string } } };

const user1: User = {}; // ❌
// Property 'profile' is missing in type '{}' but required in type 'User'

const user2: User = { profile: {} }; // ❌
// Property 'address' is missing in type '{}' but required in type
// '{ address: { street: string; city: string; state: string; }; }'

const user3: User = { profile: { address: { street: '123 Fake St' } } }; // ❌
// Type '{ street: string; }' is missing the following properties from
// type '{ street: string; city: string; state: string; }': city, state

const user1Too: Partial<User> = {}; // ✅
const user1Again: DeepPartial<User> = {}; // ✅

const user2Too: Partial<User> = { profile: {} }; // ❌
// same error as before
const user2Again: DeepPartial<User> = { profile: {} }; // ✅

const user3Too: Partial<User> = { profile: { address: { street: '123 Fake St' } } }; // ❌
// same error as before
const user3Again: DeepPartial<User> = { profile: { address: { street: '123 Fake St' } } }; // ✅
```

<!-- We could use this pattern to make DeepRequired, DeepReadonly, DeepMutable, etc. -->
<!-- Because of the + / - for `readonly` and `?` -->

---

# Modules

##### modules/animal.ts

```ts
export interface Cat { breed: string; age: number }
export type Dog = { breeds: string[]; age: number };
export const generateName = () => 'fluffy';
```

##### modules/app.ts

```ts
import { Cat, Dog, generateName } from './animal';
```

##### modules/appToo.ts

```ts
import { generateName } from './animal';
import type { Cat, Dog } from './animal';
```

##### modules/appAgain.ts

```ts
import { generateName, type Cat, type Dog } from './animal';
```

<!-- Any explicitly marked type import is guaranteed to be removed from your JavaScript -->
<!-- tools like Babel can make better assumptions about your code -->

---

# Other Features

---

# Post-fix operators

##### postFix.ts

```ts
type User = { name?: string, id: string, age?: number };

const validateUser = (user?: User) => {
  if (!user) throw new Error('Missing user!');
}

const processUser = (user?: User) => {
  console.log({ age: user?.age }); // Post-fix safe navigation

  validateUser(user);

  // At this point, we know more than TypeScript:
  // `user` is not undefined because an error would have been thrown

  const { name: badName } = user; // ❌
  // Property 'name' does not exist on type 'User | undefined'

  const badId = user.id; // ❌
  // 'user' is possibly 'undefined'

  const { name } = user!; // ✅ Post-fix non-null assertion
  const id = user!.id; // ✅ Post-fix non-null assertion
}
```

---

# Type Assertions

##### typeAssertions.ts

```ts
const myCanvas = document.getElementById('main_canvas');
const { height } = myCanvas!; // ❌
// Property 'height' does not exist on type 'HTMLElement'

const myCanvasToo = document.getElementById('main_canvas') as HTMLCanvasElement;
const { height: heightToo } = myCanvasToo!; // ✅

const x = 'hello' as number; // ❌
// Conversion of type 'string' to type 'number' may be a mistake because ...

const y = 'hello' as any as number; // ✅ (but also ❌)
const z = 'hello' as unknown as number; // ✅ (but also ❌)

// const someObj: { a: number }
const someObj = { a: 1 };
// const someObjToo: { readonly a: 1 }
const someObjToo = { a: 1 } as const;
```

---

# Enums vs const objects

---

# Enums

##### enumsVsConstObjects/sockSizes.ts

```ts
export enum SockSizes {
  small = 'SM',
  medium = 'MD',
  large = 'LG',
}
```

<!-- Are not built into JavaScript, is a TypeScript feature -->
<!-- Are values, types, and namespaces rolled into one which can be confusing at first -->
<!-- Are concise -->
<!-- See https://stackoverflow.com/questions/28818849/how-do-the-different-enum-variants-work-in-typescript for exhaustive explanation of different kinds of enums -->

##### enumsVsConstObjects/enums.ts

```ts
import { SockSizes } from './sockSizes';

const toStringLiteral: 'SM' = SockSizes.small; // ✅
const fromStringLiteral: SockSizes.small = 'SM'; // ❌
// Type '"SM"' is not assignable to type 'SockSizes.small'

const outOfStock = (size: SockSizes) => size === SockSizes.small;
```

---

# const objects

<!-- More closely aligns with pure JavaScript -->
<!-- Must build the value, type, and namespace individually -->
<!-- More verbose -->

##### enumsVsConstObjects/shirtSizes.ts

```ts
export const ShirtSizes = { small: 'SM', medium: 'MD', large: 'LG' } as const;
// type ShirtSizes = "SM" | "MD" | "LG"
export type ShirtSizes = typeof ShirtSizes[keyof typeof ShirtSizes];
export namespace ShirtSizes {
  export type small = typeof ShirtSizes.small;
  export type medium = typeof ShirtSizes.medium;
  export type large = typeof ShirtSizes.large;
}
```

##### enumsVsConstObjects/constObjects.ts

```ts
// (alias) type ShirtSizes = "SM" | "MD" | "LG"
// (alias) namespace ShirtSizes
// (alias) const ShirtSizes: Readonly<{ small: "SM"; medium: "MD"; large: "LG"; }>
// import ShirtSizes
import { ShirtSizes } from './shirtSizes';

const toStringLiteral: 'SM' = ShirtSizes.small; // ✅
const fromStringLiteral: ShirtSizes.small = 'SM'; // ✅
const outOfStock = (size: ShirtSizes) => size === ShirtSizes.large;
```

---

# Structural Typing vs Nominal Typing

---

# Structural Typing

<!-- In contrast to nominal typing, more below -->
<!-- TypeScript's system is structural -->
<!-- Think duck-typing for a type system -->

##### structuralTypingVsNominalTyping/structuralTyping.ts

```ts
type Ball = { r: number };
type Sphere = { r: number };
type Tube = { r: number; l: number };

let ball: Ball = { r: 10 };
let sphere: Sphere = { r: 20 };
let tube: Tube = { r: 12, l: 3 };

ball = sphere; // ✅
sphere = ball; // ✅
ball = tube; // ✅
sphere = tube; // ✅

tube = ball; // ❌
// Property 'l' is missing in type 'Ball' but required in type 'Tube'.
tube = sphere; // ❌
// Property 'l' is missing in type 'Ball' but required in type 'Tube'.
```

<!-- Because a ball does not have a length, then it cannot be assigned to the tube variable. However, all of the members of Ball are inside Tube, so the tube can be assigned to the ball variable. -->

---

# Nominal Typing

<!-- C++, Java, and Swift -->
<!-- Each type is unique -->
<!-- Even if types have the same data, you can't assign across types -->
<!-- We can still get nominal typing from TypeScript like: -->

##### structuralTypingVsNominalTyping/nominalTyping.ts

```ts
type USD = number & { __brand: 'USD' };
type Brand<K, T> = K & { __brand: T };
type EUR = Brand<number, 'EUR'>;

const usd = 10 as USD; // `as`
const eur = 10 as EUR; // `as`

const gross = (net: USD, tax: USD): USD => (net + tax) as USD; // `as`

gross(usd, usd); // ✅
gross(eur, usd); // ❌
// Argument of type 'EUR' is not assignable to parameter of type 'USD'.
  // Type 'EUR' is not assignable to type '{ __brand: "USD"; }'.
    // Types of property '__brand' are incompatible.
      // Type '"EUR"' is not assignable to type '"USD"'.
```

---

<div class="container" style="font-size:2rem;padding-bottom:1rem">
  <div class="col" style="width:100%;text-align:center">

# Interface
  </div>
  <div class="col" style="margin:1rem">

# vs
  </div>
  <div class="col" style="width:100%;text-align:center">

# Type Alias
  </div>
</div>

<!-- For the most part, interchangable / the same, however, we can reopen interfaces for better or for (probably) worse -->

<div class="container">
  <div class="col" style="width:100%">

##### interfaceVsTypeAlias/interface.ts

```ts
interface Animal {
  name: string;
}

interface Bear extends Animal {
  honey: boolean;
}

const bear = {} as Bear;
bear.name;
bear.honey;

interface Bear extends Animal {
  kind: 'grizzly' | 'black' | 'polar';
} // reopen Bear
```
  </div>

  <div class="col" style="margin:1rem"></div>

  <div class="col" style="width:100%">

##### interfaceVsTypeAlias/typeAlias.ts

```ts
type Animal = {
  name: string;
};

type Bear = Animal & { 
  honey: boolean;
};

const bear = {} as Bear;
bear.name;
bear.honey;

type Bear = Animal & {
  kind: 'grizzly' | 'black' | 'polar';
}; // Error: Duplicate identifier Bear
``` 
  </div>
</div>

---

# FAQs: Variance

##### faqs/variance.ts

```ts
type Animal = {}
type Dog = Animal & {}
type Cat = Animal & {}

const trainDog = (d: Dog) => {}
const cloneAnimal = (source: Animal, done: (result: Animal) => void): void => {}
const animal = {} as Animal;
const cat = {} as Cat;

cloneAnimal(animal, trainDog); // ✅
cloneAnimal(cat, trainDog); // ✅ (should be ❌)
// Expected an error here because we
// end up invoking 'trainDog' with a 'Cat'
```

<!-- Without getting too in the weeds... -->
<!-- This is an unsoundness resulting from the lack of explicit covariant/contravariant annotations in the type system. -->
<!-- Because of this omission, TypeScript must be more permissive. -->

---

# <!--fit-->JSDoc

<!-- If you don't know what JSDoc is, -->
<!-- It's a way to add type safety to pure JavaScript files -->
<!-- There are times when, from a consumer TypeScript file, we want to consume files that are in pure JavaScript and it doesn't make sense to convert to a TypeScript file; whether they're too large and it would be out of scope, changing it to TypeScript would have an uncomfortable impact, or you simply just want type safety from a subset of a file. -->
<!-- We can do this by adding type annotations with JSDoc comments in the consumee pure JavaScript file -->
<!-- This means that we have spectrum of type safety when it comes to JavaScript and TypeScript -->

---

# Type Safety In Order Of Strictness

1. TypeScript code with strict enabled
2. TypeScript code
3. Incremental typing using JSDoc in a pure JavaScript file with // @ts-check
4. Incremental typing using JSDoc in a pure JavaScript file
5. A type-system based only on inference with pure JavaScript code

<!-- Pause -->

---

# Basic Example

<!-- So here's a basic example -->
<!-- Say we have an `x` variable and we know that it's a number so we'll add a type annotation to its declaration -->
<!-- If later we try to assign a value of another type, like a boolean value false, TypeScript doesn't emit an error. -->
<!-- That's interesting, we would expect it to emit an error since false is obviously not a number. -->
<!-- Well, let's fix that by adding the ts-check comment at the top of the file. -->
<!-- E voila, now, we see that TypeScript is emitting a helpful error. -->

<!-- Pause -->

##### jsdoc/basic.js

```js
/** @type {number} */
var x;
 
x = false; // ✅ ... wait, what?
```

##### jsdoc/basicFixed.js

```js
// @ts-check

/** @type {number} */
var x;
 
x = false; // ❌
// Type 'boolean' is not assignable to type 'number'.
```

---

# Defaults

<!-- Let's look at some of the quirks of using JSDoc compared to actual TypeScript -->
<!-- Say we have a simple object variable that's instantiated with literal keys and values. -->
<!-- Then later we try to assign a value to a key that wasn't specified at the time of instantiation. -->
<!-- In a pure JavaScript file with ts-check turned on, this is okay, which deviates from actual TypeScript files. -->
<!-- In JavaScript with JSDoc, this object variable is given a looser effective type definition that it would have been given in a TypeScript file so that we can have _incremental_ type safety meaning that we don't want too many things to break as a result of our decision to add a type to this variable. -->

<!-- Pause -->

<!-- Next, any variable that's given a value at instantiation of undefined, null, or not given a value at all are all assumed to be of type `any`, loosest type definition TypeScript has. -->
<!-- The same goes for function parameters and return values of functions -->

<!-- Pause -->

<!-- And since there's no way to specify optionality on params before ES2015 (which ES3 is assumed to be the target level as it's recognized by the most browsers), all function params are considered optional; however, supplying too many arguments results in an error as that _can_ be checked by TypeScript and assumed to be an actual error -->

<!-- Pause -->

##### jsdoc/defaults.js

```js
// @ts-check

// var myObj: { a: number }
var myObj = { a: 1 };
myObj.b = 2; // ✅
// Would be ❌ in a .ts with:
// Property 'b' does not exist on type '{ a: number; }'
// This works because `myObj` is a looser effective type definition in a .js file:
// var myObj: { [x: string]: any }

// var i: any, var j: any, var k: any
var i, j = undefined, k = null;

// var foo: (a: any, b: any) => never[]
var foo = (a, b) => {
  if (!a) a = 1; // ✅

  return [];
};

// const ary: any[]
const ary = foo(); // ✅
ary.push(2); // ✅
foo(1, 'a', []); // ❌
// Expected 0-2 arguments, but got 3
```

---

# @type

<!-- Let's look at @type like we saw earlier -->
<!-- @type is a way to annotate variable and function declarations -->
<!-- Here, we have a JavaScript file on the left and its corollary TypeScript on that right for reference -->
<!-- So, if we want to declare a variable that can be a string or number, we can do that by adding the type definition in between the curlies in the @type statement just before the variable declaration -->
<!-- Here, we literally have a `numOrStr` variable that can be either a number or string at runtime -->
<!-- We can have another variable that can consume that `numOrStr` variable and TypeScript will infer that its type will also be a number or a string -->
<!-- But if we wanted to tell TypeScript that we know this will be a number, we can cast its type, or assert its type, to be a number like we would in TypeScript with the `as` keyword using an inline @type statement with the asserted type in the curlies -->
<!-- Furthermore, we can continue to let TypeScript know what type other variables will be using the same syntax as is used for `numOrStr`. -->
<!-- All we have to do is tell TypeScript what the types are by using TypeScript syntax in between the curlies at each statement -->

<!-- Pause -->


<div class="container">
  <div class="col" style="width:100%">

##### jsdoc/type.js

```ts
// @ts-check

/** @type {number | string} */
var numOrStr = Math.random() < 0.5 ? 'hello' : 100;
// var numOrStrAssertedToOnlyNum: number
var numOrStrAssertedToOnlyNum = /** @type {number} */ (numOrStr);

/** @type {number[]} */
var numbers;

/** @type {(s: string, b?: boolean) => number} */
var strAndMaybeBoolToNum;

/** @type {Record<string, number>} */
var namedNumbers;
 
/** @type {Element | null} */
var myElement = document.querySelector('.foo');
```
  </div>

  <div class="col" style="margin:1rem"></div>

  <div class="col" style="width:100%">

##### jsdoc/type.ts

```ts


// const numOrStr: "hello" | 100
const numOrStr = Math.random() < 0.5 ? 'hello' : 100;
// const numOrStrAssertedToOnlyNum: number
const numOrStrAssertedToOnlyNum = numOrStr as number;

// const numbers: number[]
let numbers: number[];

// let strAndMaybeBoolToNum: (s: string, b?: boolean) => number
let strAndMaybeBoolToNum: (s: string, b?: boolean) => number;

// let namedNumbers: Record<string, number>
let namedNumbers: Record<string, number>;
 
// const myElement: Element | null
const myElement: Element | null = document.querySelector('.foo');
``` 
  </div>
</div>

---

# @typedef

<!-- For complicated types that we want to use in the rest of the annotated JavaScript file or for types that we want to make automagically available for consumption (more on that later), we can alias types using @typedef -->
<!-- Same thing here, we have a JavaScript file on the left and its corollary TypeScript on that right for reference -->
<!-- Imagine we want to define a type alias for the props that a component can expect, it's the same idea as before with @type; just add TypeScript syntax in between curlies (you can even use multiline if you wish like for `UserProps`), the difference here is that we give the type alias at the end -->
<!-- We can define as many type aliases as we'd like to set us up for the rest of the file, or to simply make the type alias available for import -->
<!-- I'm using a class based React component here as we might encounter more of those proportionally to pure JavaScript files. -->
<!-- Notice in the constructor that we're using another @props statement, we can use this if we just want to tell TypeScript the type of the parameters for a function instead of typing the whole function -->
<!-- Notice that in `configure` and `performTask` that we can type destructured and non-destructured parameters. -->
<!-- We don't even have to name the parameter the same in the typedef as we do in the actual code but that's in direct contrast to @param where we _must_ name them the same. -->

<!-- Pause -->


<div class="container">
  <div class="col" style="width:100%">

##### jsdoc/typedef.js

```ts
// @ts-check

/**
 * @typedef {{
 *   name: string;
 *   age?: number;
 *   alive?: boolean;
 * }} UserProps
 */

/** @typedef {{ enabled?: boolean }} Configuration */

class User extends React.Component {
  /** @param {UserProps} props */
  constructor(props) { super(props); }

  /** @type {(configuration: Configuration) => void} */
  configure({ enabled }) {}

  /** @type {(todo: { what: string; dueBy?: Date; }) => void} */
  performTask(aTodo) {}
}
```
  </div>

  <div class="col" style="margin:1rem"></div>

  <div class="col" style="width:100%">

##### jsdoc/typedef.ts

```ts



type UserProps = {
  name: string;
  age?: number;
  alive?: boolean;
};


type Configuration = { enabled?: boolean };

class User extends React.Component {

  constructor(props: UserProps) { super(props); }


  configure({ enabled }: Configuration) {}


  performTask(todo: { what: string; dueBy?: Date; }): void {}   
}
``` 
  </div>
</div>

---

# Usage: Before

<!-- Let's look at how we might go about implementing this in JavaScript files for a consumer TypeScript file -->

---

<!-- Say, we have a TypeScript file that depends on a pure JavaScript file and that JavaScript file depends on another pure JavaScript file -->
<!-- For this example, our consumer TypeScript file is `ts.ts`, its dependent JavaScript file is `js.js` and its dependent is `size.js` -->
<!-- In `size.js`, we'll have an object called `Sizes` with readable keys that relate to values that mean something to an api, say, so think an enum -->
<!-- This object will house just small, medium, and large keys and values -->
<!-- In `size.js`, we export the `Sizes` object for consumers -->
<!-- Now in `js.js`, we export a function called `inStock` that takes a value of the `Sizes` object and uses the same values to determine if we have that size in stock returning a boolean as an answer to that question -->
<!-- We'll _re_export the `Sizes` object as well as our `inStock` function for consumers -->
<!-- In the end consumer `ts.ts` file, we want a way to place an order knowing that the requested size is in stock -->
<!-- So we'll import the `Sizes` object and the `inStock` function from our `js.js` file into `ts.ts` and use those to both declare a `placeOrder` function and to call that function with `Sizes` values -->
<!-- As you would expect, calling `placeOrder` with one of the deterimined `Sizes` works -->
<!-- But we want for TypeScript to error when we call that function with an argument other than what sizes we offer -->

<!-- Pause -->

<!-- Let's look at how we can accomplish this... -->

##### jsdoc/usage/before/size.js

```js
var Sizes = { sm: 'SM', md: 'MD', lg: 'LG' };
module.exports = { Sizes };
```

##### jsdoc/usage/before/js.js

```js
var { Sizes } = require('./size');
function inStock(size) { return size === Sizes.sm; }
module.exports = { Sizes, inStock };
```

##### jsdoc/usage/before/ts.ts

```ts
import { Sizes, inStock } from './js';
// const placeOrder: (size: any) => boolean
const placeOrder = (size) => inStock(size);
placeOrder(Sizes.lg); // ✅ -> false
placeOrder('XS'); // ✅ (should be ❌)
```

---

# Usage: After

---

<!-- One way to do this is to go back to the `size.js` file and start adding annotations there -->
<!-- We can add an inline type assertion to assert the `Sizes` object as a `const` which makes the entries readonly and effectively "freezes" it allowing TypeScript to know that the values will never change and so it can interpret them as string literals instead of any `string` with literal string values with a @typedef type alias definition and we'll call that `TSizes` -->
<!-- We can then infer the `typeof` the `Sizes` value and alias that as `TSizes` -->
<!-- We can then also infer the values of `TSizes` and alias that as `Size` -->
<!-- We still export the `Sizes` object -->
<!-- Then, in our `js.js` file we can actually import the `Size` type alias definition even though we didn't explicitly export it -->
<!-- This is important to know, any JSDoc type alias definition can be imported from a consumer -->
<!-- This also means that if we import a type alias definition from a source file into a target file, any consumer of the target file can import the definition as well, as we'll see -->
<!-- So we use the `Size` type to annotate that our `inStock` function expects a parameter of type `Size` and that it returns a boolean type value -->
<!-- The exports remain the same as before -->
<!-- Now, in our `ts.ts` file, we can now import the `Size` type as well from our `js.js` file and use it! -->
<!-- So we can type our `placeOrder` function to also expect a parameter of type `Size` and now if we try to call it with an unknown size, TypeScript will error! -->

<!-- Pause -->

##### jsdoc/usage/after/size.js

```js
// @ts-check
var Sizes = /** @type { const } */ ({ sm: 'SM', md: 'MD', lg: 'LG' });
/** @typedef { typeof Sizes } TSizes */
/** @typedef { TSizes[keyof TSizes] } Size */
module.exports = { Sizes };
```

##### jsdoc/usage/after/js.js

```js
// @ts-check
/** @typedef { import('./size').Size } Size */
var { Sizes } = require('./size');
/** @type { (size: Size) => boolean } */
function inStock(size) { return size === Sizes.sm; }
module.exports = { Sizes, inStock };
```

##### jsdoc/usage/after/ts.ts

```ts
import { Sizes, inStock, type Size } from './js';
const placeOrder = (size: Size) => inStock(size);
placeOrder(Sizes.lg); // ✅ -> false
placeOrder('XS'); // ❌ (yay!)
// Argument of type '"XS"' is not assignable to parameter of type 'Size'
```

---

# The End

---

<!--color: white-->

Questions

![bg](https://gifdb.com/images/high/confused-nerd-steve-brule-eixtr1f0qii8fthl.gif)

<!-- Should I pamphletize this presentation?: YES -->

<!-- Generics section -->
<!-- variants, covariants, invariants, contravariants -->

<!-- TODO: tests / exercises wherein people fix actual problems to solidify learning -->
